{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1896179272199890064,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"use dep::std::hash::poseidon;\n\n// struct Dataset {\n//     data: Field,\n// }\n\nfn main(x: Field, y: Field) -> pub Field {\n    poseidon::bn254::hash_2([x, y])\n}\n\n#[test]\nfn test_main() {\n    main(1, 2);\n}\n","path":"/Users/Kirsty/Developer/Cerebra/cerebra/src/main.nr"}},"names":["main"],"brillig_names":[]}