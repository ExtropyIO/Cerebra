{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2127570841060814051,"abi":{"parameters":[{"name":"data_points","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"DataPoint","fields":[{"name":"value","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"threshold","type":{"kind":"field"},"visibility":"private"},{"name":"expected_hash","type":{"kind":"field"},"visibility":"public"},{"name":"min_sum","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WZW27CMBBFJwm00HdLUt5kCzZJiPPHVho12f8S2im2ZCf94xrJIyFLGDln7lywPUR0ifz3taBxZHo861FcFbIHriUjIFcM5EqAXBMg1xTIdQfkugdyzYBccyDXA5DrEcj1BOR6BnK9ALlegVxvQK53INcHkGthrVWIU1l29bGThfwSx6ZVlSir9qSkkpWqvo+qKDpVqrppm1o0siw62VdN0evVMhiXEBO9TkTjiPWI4sbtLQK4H1y4TCx9Jr8EC7C0wFGctzQEsIjAjdg1xMpn8iuwACsK2xDAIgJPQK4h1j6TX4MFWFPYhgAWEXj0dA2x8Zn8BizAhsI2BLCIwDO/a4itz+S3YAG2FLYhgEUEXrZcQ+x8Jr8DC7CjsA0BLCLwlusaYu8z+T1YgD2FbQhgEYHtBdcQB5/JH8ACHChsQwCL6PR1xJVh5577TD4HC5AT3hAshjFFZq0faU0SPc+3Jm6c82GZG9V8RuLGMG+N3IjlX0RufPIXgRuNnD839pg7tfTlZ3zSOExR5oMxs+aRfQyzfupn/b9LxTBsfdNBnrE1dwYxmPUSPU5pHPFgznx2NuCL8HySBpH88ywT5g++1HrP6PkDHC71gwkcAAA=","debug_symbols":"ndNBCoMwEAXQu8zahZNWa3KVUiRqlEBIJMZCEe/eKApSupks/wxvNvlZoFPNPNTa9m4C8VzAuFYG7WxMC+T7aBql3dIUpA8gKs4yULYDwRlbM+i1USBKXF8Z4D+APC8PgRyLH8Lo5EYndzop6KSkkwedVHTC6QTzBJPw/phQAExoACZUABM6gAklwIQWILkGMTReG6OH+vrL4/gtvZaNUUfsZ9tetuEznpvTj961qpu92i7tu3j+Cw==","file_map":{"61":{"source":"// Data point structure representing each entry in your dataset\nstruct DataPoint {\n    value: Field,\n    timestamp: Field,\n}\n\n// Main circuit function that verifies dataset properties\nfn main(\n    // Array of data points (can be adjusted based on your dataset size)\n    data_points: [DataPoint; 10], \n    \n    // Threshold to verify against\n    threshold: Field, \n    \n    // Expected hash of the data (public input that will be visible on-chain)\n    expected_hash: pub Field,\n    \n    // Minimum required sum (public parameter)\n    min_sum: pub Field\n) {\n    // Calculate a simple hash of the data points\n    let mut computed_hash = 0;\n    for i in 0..10 {\n        // Simple hash combining value and timestamp\n        computed_hash = computed_hash + (data_points[i].value * 31 + data_points[i].timestamp * 17);\n    }\n    \n    // Verify the computed hash matches the expected hash\n    assert(computed_hash == expected_hash);\n    \n    // Calculate the sum of all values\n    let mut sum = 0;\n    for i in 0..10 {\n        sum = sum + data_points[i].value;\n    }\n    \n    // We'll use multiplication tricks to enforce comparison constraints\n    // For a >= b, we need to prove there exists c where a = b + c\n    \n    // For sum >= threshold:\n    let diff1 = sum - threshold;\n    let is_positive1 = diff1 * diff1; // This will only be zero if diff1 is 0\n    assert(sum == threshold + diff1);\n    \n    // For sum >= min_sum:\n    let diff2 = sum - min_sum;\n    let is_positive2 = diff2 * diff2; // This will only be zero if diff2 is 0\n    assert(sum == min_sum + diff2);\n    \n    // Verify timestamps are monotonically increasing\n    for i in 1..10 {\n        let diff = data_points[i].timestamp - data_points[i-1].timestamp;\n        // For strict inequality (a > b), we need to prove there exists c where a = b + c + 1\n        assert(data_points[i].timestamp == data_points[i-1].timestamp + diff);\n        assert(diff != 0); // This enforces strict inequality\n    }\n    \n    // Verify no single value exceeds twice the average\n    let average = sum / 10;\n    let max_value = average * 2;\n    \n    for i in 0..10 {\n        let diff = max_value - data_points[i].value;\n        // For a <= b, we need to prove there exists c where b = a + c\n        assert(max_value == data_points[i].value + diff);\n    }\n    \n    // Verify timestamps are within a reasonable range (not in the future)\n    let current_time = 1683000000; // Example: May 2023 in Unix timestamp\n    \n    for i in 0..10 {\n        let diff = current_time - data_points[i].timestamp;\n        // For a <= b, we need to prove there exists c where b = a + c\n        assert(current_time == data_points[i].timestamp + diff);\n    }\n    \n    // The proof is valid only if all assertions pass\n}","path":"/Users/extropy/Work/Dev/Cerebra/cerebra/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}